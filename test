#!/bin/bash

usage() {
  echo "Usage:"
  echo "  $0 --file <json_file>"
  exit 1
}

# Fetch headers and return a clean JSON object using jq
parse_headers() {
  local name="$1"
  local url="$2"
  local version="$3"
  
  # Fetch headers (only for non-null URLs)
  local headers
  headers=$(curl -s -I -L "$url") # -L follows redirects

  local status_code=$(echo "$headers" | grep -m 1 "HTTP/" | awk '{print $2}')
  local content_length=$(echo "$headers" | grep -i "Content-Length" | awk '{print $2}' | tr -d '\r')
  local content_type=$(echo "$headers" | grep -i "Content-Type" | awk '{print $2}' | tr -d '\r')
  local content_disp=$(echo "$headers" | grep -i "Content-Disposition" | cut -d':' -f2- | xargs | tr -d '\000-\037')

  # Use jq to construct the object to handle escaping and types correctly
  jq -n \
    --arg name "$name" \
    --arg url "$url" \
    --arg ver "$version" \
    --arg status "${status_code:-0}" \
    --arg len "${content_length:-unknown}" \
    --arg type "${content_type:-unknown}" \
    --arg disp "${content_disp:-none}" \
    '{
      name: $name,
      url: $url,
      version: $ver,
      status: ($status | tonumber),
      valid: ($status == "200"),
      content_length: $len,
      content_type: $type,
      content_disposition: $disp
    }'
}

if [ $# -ne 2 ] || [ "$1" != "--file" ]; then
  usage
fi

JSON_FILE="$2"

if [ ! -f "$JSON_FILE" ]; then
  echo "Error: File not found: $JSON_FILE"
  exit 1
fi

# Process the file
results=()
echo "["

# Extract entries that have a valid (non-null) iso_url
# We look for .os_version OR .version to support both files
entries=$(jq -c '.[] | select(.iso_url != null)' "$JSON_FILE")

first=1
while read -r entry; do
  name=$(echo "$entry" | jq -r '.name')
  url=$(echo "$entry" | jq -r '.iso_url')
  # Try os_version first, then version
  version=$(echo "$entry" | jq -r '.os_version // .version // "N/A"')

  if [ $first -eq 0 ]; then
    echo ","
  fi
  
  parse_headers "$name" "$url" "$version"
  first=0
done <<< "$entries"

echo "]"
